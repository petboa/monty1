#include <string.h>

void free_tokens(void);
unsigned int token_arr_len(void);
int is_empty_line(char *line, char *delims);
void (*get_op_func(char *opcode))(stack_t**, unsigned int);
int run_monty(FILE *script_fd);

/**
 * free_tokens - Frees the global op_toks array of strings.
 */
void free_tokens(void)
{
  size_t i = 0;

  if (op_toks == NULL)
    return;

  for (i = 0; op_toks[i]; i++)
    free(op_toks[i]);

  free(op_toks);
}

/**
 * token_arr_len - Gets the length of current op_toks.
 *
 * Return: Length of current op_toks (as int).
 */
unsigned int token_arr_len(void)
{
  unsigned int toks_len = 0;

  while (op_toks[toks_len])
    toks_len++;
  return (toks_len);
}

/**
 * is_empty_line - Checks if a line read from getline only contains delimiters.
 * @line: A pointer to the line.
 * @delims: A string of delimiter characters.
 *
 * Return: If the line only contains delimiters - 1.
 *         Otherwise - 0.
 */
int is_empty_line(char *line, char *delims)
{
  int i, j;

  for (i = 0; line[i]; i++)
    {
      for (j = 0; delims[j]; j++)
	{
	  if (line[i] == delims[j])
	    break;
	}
      if (delims[j] == '\0')
	return (0);
    }

  return (1);
}

/**
 * get_op_func - Matches an opcode with its corresponding function.
 * @opcode: The opcode to match.
 *
 * Return: A pointer to the corresponding function.
 */
void (*get_op_func(char *opcode))(stack_t**, unsigned int)
{
  instruction_t op_funcs[] = {
			      {"push", monty_push},
			      {"pall", monty_pall},
			      {"pint", monty_pint},
			      {"pop", monty_pop},
			      {"swap", monty_swap},
			      {"add", monty_add},
			      {"nop", monty_nop},
			      {"sub", monty_sub},
			      {"div", monty_div},
			      {"mul", monty_mul},
			      {"mod", monty_mod},
			      {"pchar", monty_pchar},
			      {"pstr", monty_pstr},
			      {"rotl", monty_rotl},
			      {"rotr", monty_rotr},
			      {"stack", monty_stack},
			      {"queue", monty_queue},
			      {NULL, NULL}
  };
  int i;

  for (i = 0; op_funcs[i].opcode; i++)
    {
      if (strcmp(opcode, op_funcs[i].opcode) == 0)
	return (op_funcs[i].f);
    }

  return (NULL);
}

/**
 * run_monty - Primary function to execute a Monty bytecodes script.
 * @script_fd: File descriptor for an open Monty bytecodes script.
 *
 * Return: EXIT_SUCCESS on success, respective error code on failure.
 */
int run_monty(FILE *script_fd)
{
  stack_t *stack = NULL;
  char *line = NULL;
  size_t len = 0, exit_status = EXIT_SUCCESS;
  unsigned int line_number = 0, prev_tok_len = 0;
  void (*op_func)(stack_t**, unsigned int);

  if (init_stack(&stack) == EXIT_FAILURE)
    return (EXIT_FAILURE);

  while (getline(&line, &len, script_fd) != -1)
    {
      line_number++;
      op_toks = strtow(line, DELIMS);
      if (op_toks == NULL)
	{
	  if (is_empty_line(line, DELIMS))
	    continue;
	  free_stack(&stack);
	  return (malloc_error());
	}
      else if (op_toks[0][0] == '#') /* comment line */
	{
	  free_tokens();
	  continue;
	}
      op_func = get_op_func(op_toks[0]);
      if (op_func == NULL)
	{
	  free_stack(&stack);
	  exit_status = unknown_op_error(op_toks[0], line_number);
	  free_tokens();
	  break;
	}
      prev_tok_len = token_arr_len();
      op_func(&stack, line_number);
      if (token_arr_len() != prev_tok_len)
	{
	  if (op_toks && op_toks[prev_tok_len])
	    exit_status = atoi(op_toks[prev_tok_len]);
	  else
	    exit_status = EXIT_FAILURE;
	  free_tokens();
	  break;
	}
      free_tokens();
    }
  free_stack(&stack);

  if (line && *line == 0)
    {
      free(line);
      return (malloc_error());
    }

  free(line);
  return (exit_status);
}~#ifndef __MONTY_H__
#define __MONTY_H__

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define STACK 0
#define QUEUE 1
#define DELIMS " \n\t\a\b"

/* GLOBAL OPCODE TOKENS */
extern char **op_toks;

/**
 * struct stack_s - doubly linked list representation of a stack (or queue)
 * @n: integer
 * @prev: points to the previous element of the stack (or queue)
 * @next: points to the next element of the stack (or queue)
 *
 * Description: doubly linked list node structure
 * for stack, queues, LIFO, FIFO Holberton project
 */
typedef struct stack_s
{
	int n;
	struct stack_s *prev;
	struct stack_s *next;
} stack_t;

/**
 * struct instruction_s - opcode and its function
 * @opcode: the opcode
 * @f: function to handle the opcode
 *
 * Description: opcode and its function
 * for stack, queues, LIFO, FIFO Holberton project
 */
typedef struct instruction_s
{
	char *opcode;
	void (*f)(stack_t **stack, unsigned int line_number);
} instruction_t;

/* PRIMARY INTERPRETER FUNCTIONS */
void free_stack(stack_t **stack);
int init_stack(stack_t **stack);
int check_mode(stack_t *stack);
void free_tokens(void);
unsigned int token_arr_len(void);
int run_monty(FILE *script_fd);
void set_op_tok_error(int error_code);

/* OPCODE FUNCTIONS */
void monty_push(stack_t **stack, unsigned int line_number);
void monty_pall(stack_t **stack, unsigned int line_number);
void monty_pint(stack_t **stack, unsigned int line_number);
void monty_pop(stack_t **stack, unsigned int line_number);
void monty_swap(stack_t **stack, unsigned int line_number);
void monty_add(stack_t **stack, unsigned int line_number);
void monty_nop(stack_t **stack, unsigned int line_number);
void monty_sub(stack_t **stack, unsigned int line_number);
void monty_div(stack_t **stack, unsigned int line_number);
void monty_mul(stack_t **stack, unsigned int line_number);
void monty_mod(stack_t **stack, unsigned int line_number);
void monty_pchar(stack_t **stack, unsigned int line_number);
void monty_pstr(stack_t **stack, unsigned int line_number);
void monty_rotl(stack_t **stack, unsigned int line_number);
void monty_rotr(stack_t **stack, unsigned int line_number);
void monty_stack(stack_t **stack, unsigned int line_number);
void monty_queue(stack_t **stack, unsigned int line_number);

/* CUSTOM STANDARD LIBRARY FUNCTIONS */
char **strtow(char *str, char *delims);
char *get_int(int n);

/* ERROR MESSAGES & ERROR CODES */
int usage_error(void);
int malloc_error(void);
int f_open_error(char *filename);
int unknown_op_error(char *opcode, unsigned int line_number);
int no_int_error(unsigned int line_number);
int pop_error(unsigned int line_number);
int pint_error(unsigned int line_number);
int short_stack_error(unsigned int line_number, char *op);
int div_error(unsigned int line_number);
int pchar_error(unsigned int line_number, char *message);

#endif /* __MONTY_H__ */
